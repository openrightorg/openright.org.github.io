<h1>Atari Pokey to Csound Conversion</h1>

<i>by Don Mahurin, 2006-12-26</i>

<p>
(Jump to the <a href="#files">Files</a>, <a href="#quick">Quick start</a>, or <a href="#examples">Examples</a> section if you are in a hurry)
<p>
Years ago, I had seen Atari 8-bin emulators like atari800.sf.net,
and thought that a good feature to add would be the ability to dump the Pokey audio chip state
in order to be able to playback the music and sounds later ( possibly enhance the playback as well ).
No, not saving a Wave file, but the Pokey registers themselves.
SID files were available in the C64 realm; the same was bound to be created
for the old Atari 8 bit.

<p>
Then later Atari SAP files were created, which are dumps of music data from
the games similar to the SID files for the C64. The ASAP collection provided a big library of old atari sounds and music.

<p>
But the SAP files all contained 6502 assembly that actually played the music.
I known that this can allow complex song changes, but for most every song, just having the sound data would be enough. I didn't think that a SAP player should really have to emulate the 6502 (Rather just the Pokey audio chip).

<p>
The SAP Specification described a SAP Type R format, but I saw no examples of these, and no players supported this.

SAP Type R was described as:
<pre>
TYPE R - Registers. In this type, binary part is not an Atari binary file.
This part contains values that will be directly written to Pokey
registers ($D200-$D208) in 1/50s intervals (or intervals defined
with FASTPLAY tag).
</pre>

I implemented SAP-R support for the asap player/converter and the atari800 emulator. 
<p>
I made the following software changes to support SAP Type R.

<ul>
 <li> Modified atari800.sf.net to allow dumping audio as SAP Type R.
 <li> Modified asap.sf.net to allow reading SAP Type R files.
 <li> Modified asap.sf.net to allow saving SAP Type R rather than Wave files.
</ul>
(see <a href="#files">files</a> section)

<p>
The last two may be of interest to ASMA users, as these together allow one
to convert SAP Files to SAP Type R files.

<p>
Now why would you want SAP Type R files? Well, with a SAP Type R file, you now just have a piece of Music that could be played with a much simpler player. Note that the space savings of using 6502 SAP files is not really sigificant. They are both very small. Gzip will make a SAP-R file smaller than a SAP-6502 file if that is what you want.

<p>
But the real reason (for me) to have a SAP-R file is to have a sound/music file that is easier to directly convert into another music format.

<p>
And that is what you may be looking for, if you have gotten here. Below is a Perl application that converts a SAP Type R file into a Csound .csd file.
(see <a href="#files">files</a> section)

<p>
There are a couple things not implemented, but for the most part, it covers most aspects of the Pokey chip.

<p>
Some features:

<ul>
 <li> instead of square waves, a custom exponential wave is used.
   (I tried to match the wave shown at <a href="http://www.xmission.com/~trevin/atari/pokey_regs.html">Pokey Registers - Acutal Waveform</a> first, but that did not sound right, at all)
 <li> amplitude and frequency are smoothed, to get rid of clicks and harsh transitions.
 <li> Poly17/Poly9 simulated with simple random data.
 <li> Poly4 and Poly5 work. See the <a href="#poly">Poly</a> section to understand the challenge of matching the expected pseudo-random harmonic patterns.
</ul>

Missing features:

<ul>
 <li> Poly9 is treated the same as Poly17. I don't know if it should.
 <li> Poly5+Poly17 is treated the same as Poly17.
 <li> Poly5+Poly4 is not implemented. See the <a href="#poly">Poly</a> section.
</ul>

Todo:

<ul>
 <li>I can still hear clicks when using pure sine waves. These need to be removed.
 <li>support Poly5+Poly4. Some games rely on this.
 <li> Use the orchestra portion of the csound file with realtime data input.
The sapr2csound orchestra setup should be able to be used in realtime with little modification. All that is really needed is to convert atari800.sf.net or mame to output compatible realtime score data instead of doing pokey emulation. The poly simulation algorithm would need to be converted to C. The cound connection could be a named pipe of score data, or use libcsound directly (better).
 <li>Find out what the distribution of Poly5+Poly17 should be.
</ul>

<p>
<a name="quick"/><h3>Quick start</h3></a>
To convert atari sounds to Csound:
<ul>
 <li>Get latest ASMA collection from <a href="http://asma.atari.org/">http://asma.atari.org/</a> 
 <li>Get latest asap release from <a href="http://asap.sf.net/">http://asap.sf.net</a>
 <li>Apply asap patch below
 <li>build asap2wav
 <li>Convert SAP file to SAP-R: asap2wav -R -o Game.r.sap Game.sap
 <li>Using sapr2csound below, convert to csd:<br>
     sapr2csound < Game.r.sap > Game.csd
 <li>Play or convert to wav using csound:<br>
     csound -W Game.csd
</ul>

<a name="files"><h3>Files</h3></a>
<h4>SAP support for ASAP and atari800.sf.net</h4>
ASAP patched for SAP-R Read/Write: <a href="http://github.com/dmahurin/asaptools">github.com/dmahurin/asaptools</a>
<br>
Atari800 SAP-R dump patch: <a href="atari800-sapsave.patch">atari800-sapsave.patch</a>
<br>
SAP-R to Csound: <a href="sapr2csound">sapr2csound</a>
<br>
<h4>Realtime Csound output in atari800.sf.net</h4>
<ul>
<li><a href="atari800-csound.patch">atari800-csound.patch</a>
<li><a href="atari_csound.c">atari_csound.c</a>
<li><a href="atari_csound.h">atari_csound.h</a>
<li><a href="atari.orc">atari.orc</a>
</ul>
<h4>SAP-R tools</h4>
SAP-R Shrink: <a href="saprshrink">saprshrink</a>
<br>
SAP-R to HEX: <a href="sap2hex">sap2hex</a>
<br>
HEX to SAP-R: <a href="hex2sap">hex2sap</a>
<br>
<h4>Other</h4>
Big endian patch for saplib: <a href="saplib-1.5.4-endian.patch">saplib-1.5.4-endian.patch</a>
 
<a name="examples"><h3>Examples</h3></a>

Below are some examples of a SAP Type-R file, resulting CSound files, and corresponding mp3 output.
They were created from the rendition of J. S. Bach's Toccata and Fugue in D Minor, in the game "Gyruss".
<p>
<a href="gyruss.sap">gyruss.sap</a><br>
<a href="gyruss.csd">gyruss.csd</a><br>
<a href="gyruss.mp3">gyruss.mp3</a><br>
<b>Reverb version</b><br>
<a href="gyruss-reverb.csd">gyruss-reverb.csd</a><br>
<a href="gyruss-reverb.mp3">gyruss-reverb.mp3</a><br>

<p>
<a name="poly"><h3>Polynomial simulation</h3></a>
The POKEY uses pseudo-random masks for effects, by using the masks to remove parts original sound.
<p>
The masks are generated by using a polynomial feedback circuit (or Linear
feedback shift register
<a href="http://en.wikipedia.org/wiki/Linear_feedback_shift_register">Linear Feeback Shift Register</a>(LFSR))
<br>
See: <a href="http://www.atariarchives.org/dere/chapt07.php">De Re Atari -
Chapter 7</a>
<br>
See: <a
href="http://homepage.ntlworld.com/kryten_droid/Atari/800XL/atari_hw/pokey.htm">Atari Pokey Data Sheet</a>

<p>
The result is a repeating, all encompasing, pattern of numbers.
For 4 bits, 1-15, for 5 bits, 1-31, for 9 bits, 1-511, for 17 bits, 1-131071.
While the largest polynomial can be aproximated with random numbers, the same
is not true for the smaller polynomials which generate consistent harmonics,
in a irregular pattern.
Note that the mask itself uses only one bit(the first) of each number for
masking.

<p>
Each mask pattern, combined with each frequency (using logical at the
occurance a frequency signal) will
result in a new pattern for each frequency. This new pattern will always repeat after N number of cycles, where N is the size of the original polynomial pattern.

<p>
For 4 and 5 bit polynomials the resulting pattern for a frequency can be
represented an integer number (17 or 31 bits), and passed to Csound. This number can
be used to recreate the sound, using 1/15's or 1/31's harmonics for each bit.
<p>
For 9 bits, 511 bits is too big obviously using this method, and is not yet supported. Possibly, it could be supported by folding the pattern and coming up with a 12 bit or 24 bit pattern approximation. (12 and 24, because they would match western music harmonies).
<p>
For 5+4 polynomials (see audctl), the masks are both appied. The resulting
polynomial pattern would be at most 465 bits long(15 *31). Folding could be
again used.
<p>
For 5+17 polynomials, the resulting pattern is 4063201 bits long. I am not yet
sure how this effects the random sound. It would generally lower the
frequency.

